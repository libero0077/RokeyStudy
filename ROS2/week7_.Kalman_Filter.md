### 필터
(신호 처리 분야에서) 특정한 신호에서 원하지 않는 신호(Noise)를 차단하거나 원하는 신호(signal)만 통과시키는 기능을 하는 장치 혹은 그러한 과정
<br/><br/>

### 잡음(Noise)
관측하고자 하는 데이터는 크게 3가지로 분류할 수 있다.

#### 1. 실제값
실제로 그 데이터가 가져야 할 값 (ex. 자동차가 실제로 있는 위치, 현재의 실제 속도 등)  
#### 2. 측정값. 실제 측정한 데이터
센서를 통해 관측된 값 (ex. GPS를 통해 수집된 위치, 속도감지센서를 통해 수집된 속도 등)  
> #### 센서 또는 측정값의 잡음(Measurement Noise)  
> 센서는 항상 정확하지 않으며, 측정값은 노이즈를 포함한다.
> 센서는 구조적으로 실제값을 정확히 담지 못하기도 한다.
> - 로켓 엔진 표면의 센서를 통해 엔진 내부 농도를 측정한다.
> - 몇몇 대표 지점에 설치된 센서로 수질을 측정한다.
> - 터널 내 자동차 위치는 속도계와 가속도계를 사용해 측정한다.

노이즈값을 상수로 정의하면 되겠네!  
　→ 노이즈 자체도 일정하게 발생하지 않는다.  
　　→ 특정 센서에서는 측정값과 함께 분포와 표준편차를 제시한다.   
#### 3. 추정값. 시스템 동역학 모델
센서 데이터와 여러 가정들을 바탕으로 있을 것이라 추정되는 값 (ex. 특정 계산식을 통해 도출된 추정위치, 이전 속도를 기반으로 도출된 현재 속도의 추정치 등)
> #### 시스템 동역학의 잡음(Process Noise)
> 실제 상황에는 통제된 실험 환경이나 가정(완전한 평면, 일정한 타이어 압력, 정확한 속도계, 기타 물리 화학 전기적 완전무결성) 등이 작용하지 않고, 예상 밖의 수많은 변수가 존재한다.  
> 실제값과 대부분 괴리가 있기 때문에 추정방식은 항상 실제값과 비교해서 보정(update)되어야 한다.

<br/><br/>

### 따라서
이처럼 측정만 하거나 추정만 할 경우 실제값과 항상 괴리가 존재하게 된다.  
***칼만 필터***는 이런 상황에서 수학적인 시스템 동역학 모델과 노이즈가 섞이거나 제한적으로 측정된 실측 데이터를 동시에 고려하여 실제값을 가장 그럴듯하게 표현하는 위치를 찾는(추정 오차를 최소화하는) 알고리즘이다.
<br/><br/>

----

<br/><br/>
# 칼만 필터(Kalman filter)
칼만 필터(Kalman filter)는 잡음이 포함되어 있는 측정치를 바탕으로 선형 역학계의 상태를 추정하는 재귀 필터로, 루돌프 칼만이 개발하였다.  
과거에 수행한 측정값을 바탕으로 현재의 상태 변수의 결합분포를 추정하며, 컴퓨터 비전, 로봇 공학, 레이다 등의 여러 분야에 사용된다.  
<br/><br/>

### 적용 분야
칼만 필터는 물체의 측정값에 확률적인 오차가 포함되고, 또한 물체의 특정 시점에서의 상태가 이전 시점의 상태와 선형적인 관계를 가지고 있는 경우 적용이 가능하다.  
예를 들어, 레이더 추적의 경우 특정 물체의 위치, 속도, 가속도 등을 측정할 수 있지만 이 측정값에 오차가 포함되어 있을 수 있다. 이 경우, 연속적으로 측정하는 값들을 칼만 필터를 이용해서 해당 물체의 위치를 추정할 수 있다.
<br/><br/>

### 중요한 가정

#### 1. 선형성
시스템 동역학이 선형성을 만족한다고 가정한다. 입력이 2배면 출력도 2배, 입력이 여러개여도 출력은 입력 사이의 '선형 결합'으로 표현되어야 한다.
#### 2. 가우시안 노이즈
랜덤한 프로세스 노이즈와 관측 노이즈를 갖는 상황에서도, 이 노이즈는 평균이 0인 정규분포를 따른다고 가정한다.  
```
그러나 실제 세상은 대부분 비선형이다. 따라서 칼만 필터 역시 process noise가 있다고 할 수 있다.
때문에 몬테카를로, 베이지안 필터링 등과의 조합이 필요해진다. 비선형에서는 확장 칼만 필터, 파티클 필터 등이 제시된다.
```
#### 3. 재귀성
오직 이전 시간(n)과 현재 시간(n+1)의 상태에 대한 관측값과 입력값들만 이용하여 계산한다. 재귀성 하에서는 이전 시간(n)이 그 이전의 모든 시간(~ n-1)의 모든 입력에 대한 결과를 나타낸다. 따라서 1차 Markov process를 따른다고 말할 수 있다.
> 이 가정이 칼만 필터가 비용효율적일 수 있는 이유이다. 모든 상태를 기억할 필요가 없기 때문에 많은 계산량을 필요로 하지 않게 된다.  
> 이것이 임베디드 시스템과 실시간 시스템에 칼만 필터를 사용하는 이유이다.

<br/><br/>
### 구조
칼만 필터는 재귀적으로 동작한다. 즉, 칼만 필터는 바로 이전 시간에 추정한 값을 토대로 해서 현재의 값을 추정하며, 바로 이전 시간 외의 측정값이나 추정값은 사용하지 않는다.  
알고리즘은 예측과 업데이트의 두 단계로 이루어진다.
<br/><br/>
<img src = "https://github.com/user-attachments/assets/3dff97d4-b1bd-4871-aafa-c10f49da7ed6" width = "70%">  

#### 1. 예측(predict) 단계  
예측 단계에서는 현재(n) 상태 변수의 값과 정확도를 예측한다.  
이전 step(n-1)에 추정된 상태에 대해, 그 상태에서 사용자 입력을 가했을 때 예상되는 측정값을 계산하는 방식이다.
#### 2. 보정(update) 단계
업데이트 단계에서는 이전에 추정한 상태 변수를 기반으로 예측한 측정치와 실제 측정치의 차이를 반영해 현재의 상태 변수를 업데이트한다.  
시스템에 따라서 보정단계가 가끔씩 일어날 수도 있다. 이때에는 예측단계가 여러번 수행되다가 한번씩 보정단계가 수행된다.
<br/><br/>
<img src = "https://github.com/user-attachments/assets/40a3addc-aa57-4ddb-b441-bb7ddad38922" width = "40%"> 

https://github.com/user-attachments/assets/fe016019-a15c-43e8-a15e-3336e048e71b

---
<br/><br/>

## 코드 확인
#### 필요한 라이브러리 import
```python
import numpy as np
import matplotlib.pyplot as plt
```
<br/><br/>
#### 시간과 간격 설정
```python
dt = 1.0                 # 시간 간격
t = np.arange(0, 10, dt) # 시간 배열
```
> array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])

<br/><br/>

#### 실제 위치와 측정값 생성. 등가속도 운동을 가정하며 가속도는 2로 임의로 지정
```python
actual_position = 0.5 * 2 * t**2   # 차량의 실제 위치(등가속도 운동 공식에서 유도)
actual_velocity = 2 * t            # 차량의 실제 속도(초기위치 + 가속도 * 시간)
```
> array([ 0.,  1.,  4.,  9., 16., 25., 36., 49., 64., 81.])   
> array([ 0.,  2.,  4.,  6.,  8., 10., 12., 14., 16., 18.])

<br/><br/>

#### 측정값 생성
```python
measurements_position = actual_position + np.random.normal(0, 5, size=len(t)) # 실제 위치에 평균 0, 표준편차 5인 임의의 노이즈 더하기
measurements_velocity = actual_velocity + np.random.normal(0, 2, size=len(t)) # 실제 속도에 평균 0, 표준편차 2인 임의의 노이즈 더하기
```
> array([ 4.46065096,  1.58282494,  9.8391398 , 16.60909951, 20.04666437, 23.98257863, 27.61331045, 44.52920987, 72.63969316, 84.12414475])  
> array([-3.1710324 ,  6.35443145,  4.21145802,  0.73205535,  7.66282983, 7.08918785,  9.39550633, 12.50008152, 14.85093153, 17.90557159])

<br/><br/>

#### 초기 예측값과 불확실성 설정
```python
x_est = np.array([0, 0]) # 초기 예측값 (처음에는 임의로 둘 다 0으로 추정)
P = np.eye(2)            # 높은 초기 불확실성. 오차 공분산이라고도 함. 대각 성분이 1인 2*2 단위 행렬 생성
```
> array([0, 0])   
> array([[1., 0.],   
　　　[0., 1.]])
<br/><br/>

#### 상태 천이 행렬과 관측 행렬, 프로세스 노이즈와 측정 노이즈 공분산
```python
A = np.array([[1, dt],
              [0, 1]])   # 상태 천이 행렬.
# 상태공간방정식의 일부로, 직접 구하기에는 본인이 적용하고자 하는 field에 대한 물리적, 수학적 이해가 필요하다.
# 여기서는 등속도 운동을 전제한다.
# 시간 간격 dt 동안 시스템 상태가 어떻게 변화할 지를 나타낸다.
# 위치와 속도가 포함된 백터 형태로, 위치 변화는 시간 변화량(dt)*속도(2)로 반영될 것이며 속도는 그대로 유지될 것이다.

```
- 위치가 10, 속도가 2일 때 다음 위치를 예측하는 법은 다음과 같다.
<br/><br/>
![image](https://github.com/user-attachments/assets/c89b20d5-dc74-44e6-869a-6c258307d332)
<br/><br/>
```python
H = np.eye(2)            # 관측 행렬.
# 마찬가지로 상태공간방정식의 일부이다.
# 측정 가능한 요소만 골라내는 역할을 하는 행렬이다.
# 지금은 2*2 단위 행렬로 위치와 속도를 그대로 관측할 수 있음을 의미한다.
# 위치만 관측할 수 있을 경우 H = np.array([[0, 1]]) 이 될 것이며, 속도를 기준으로 하고싶으면 반대로 설정하면 된다.
```
```python
Q = np.array([[0.1, 0],
              [0, 0.1]]) # 프로세스 노이즈 공분산.
# 예측한 상태와 실제 상태 간의 불확실성을 나타낸다. 고려하지 못한 외부 요인에 의한 오차.
# 지금은 위치와 속도에 대한 예측 불확실성이 0.1로 설정되어 있다.
# 이 값이 높을 수록 예측값보다 측정값을 더 신뢰하게 되며, 작을 수록 예측값을 더 신뢰한다.
# 시스템의 노이즈가 크면 Q를 키워 측정값에 더 빠르게 반응하게 하고, 안정적인 시스템에서는 Q를 작게 해서 예측값을 더 따르게 할 수 있다.
```
```python
R = np.array([[5, 0],
              [0, 2]])   # 측정 노이즈 공분산
# 센서 측정값과 실제 상태 간의 불확실성을 나타낸다. 센서 자체가 항상 100% 정확할 수 없기 때문에 생기는 오차.
# 지금은 위치 측정의 노이즈가 5, 속도 측정의 노이즈가 2로 설정되어 있다.
# 이 값이 높을 수록 측정값보다 예측값을 더 신뢰하게 되며, 작을 수록 측정값을 더 신뢰한다.
# 센서가 노후화되거나 노이즈가 많은 환경에서는 R을 키워 측정값에 덜 의존하게 하고, 센서를 신뢰할 경우 R을 작게 해서 측정값을 더 따르게 할 수 있다.
```
<br/><br/>

#### 칼만 필터 순환
칼만 필터 순환은 매번 같은 구조로 이루어진다. (매번 같은 식이 적용된다.)

```python
x_estimates = []             # 예측값들을 저장할 빈 리스트
for i in range(len(t)):
    z = np.array([measurements_position[i], measurements_velocity[i]])

    # 예측 단계
    x_pred = A @ x_est       # 예측한 위치.
                             # 현재 시점에서 모델이 예측한 위치와 속도를 의미한다.
                             # 이전 상태인 x_est와 천이 행렬 A를 곱해 현재 위치를 예측한다. 앞서 설명한 과정을 따름.

    P_pred = A @ P @ A.T + Q # 예측한 불확실성.
                             # 천이 행렬 A에 이전 오차 공분산 P를 곱한 후 A의 전치 행렬을 다시 곱해주고, 프로세스 노이즈 Q를 더함.
                             # Gaussian distribution을 가정했기 때문에 더할 수 있다.
                             # [1] Q가 커지면 P_pred가 커진다.

    # 업데이트 단계
    K = P_pred @ H.T @ np.linalg.inv(H @ P_pred @ H.T + R)  # 칼만 이득(kalman gain).
                                                            # 예측값과 측정값의 불확실성을 바탕으로 각각을 얼마나 신뢰할지 결정하는 비율. 클 수록 측정값, 작을 수록 예측값 신뢰.
                                                            # K = P_pred * Ht * (H*P*Ht + R)^(-1)
                                                            # [2] 식을 정리하면 K = P_pred * Ht / (H*P*Ht + R)
                                                            # [3] 즉, P_pred가 커지면 K가 증가, R이 커지면 K는 감소한다.

    x_est = x_pred + K @ (z - (H @ x_pred))                 # 예측 위치 업데이트
                                                            # 실제 측정값(z)을 바탕으로 예측값을 조정한다.
                                                            # 예측 상태(x_pred)에 관측 행렬(H)를 곱해서 예측 측정값을 계산한다.
                                                            # z - (H @ x_pred): 실제 측정값(z)과 예측 측정값(H @ x_pred)의 차이는 관측 오차(잔차)이다.
                                                            # [4] 식을 정리하면 (1-K) * x_pred + K * z
                                                            # [5] 즉 K가 증가하면 예측값, 감소하면 실제 측정값에 더 큰 비중을 준다.

    P = (np.eye(2) - K @ H) @ P_pred                        # 예측 불확실성 업데이트
    x_estimates.append(x_est.copy())                                                        
x_estimates = np.array(x_estimates)  # 추정된 위치 추가
```
<br/><br/>

#### 결과 시각화
```python
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.plot(t, actual_position, label='actual_position')
plt.plot(t, measurements_position, label='measurements_position', linestyle='dotted')
plt.plot(t, x_estimates[:, 0], label='x_estimates', linestyle='--')
plt.legend()
plt.show()
```
![image](https://github.com/user-attachments/assets/5b0bde83-dbdd-4005-b7d9-7a0ffb34c335)
<br/><br/>

## 결론
### 칼만 필터
#### 칼만 필터(Kalman filter)는 잡음이 포함되어 있는 측정치를 바탕으로 선형 역학계의 상태를 추정하는 재귀 필터이다.
#### 과거에 수행한 측정값을 바탕으로 현재의 상태 변수의 결합분포를 추정한다.
#### 칼만 이득(Kalman gain) 값을 통해 예측값과 측정값 사이 비중을 조절한다.
#### 대부분의 상황은 비선형성을 갖기 때문에, 확장 칼만 필터가 가장 보편적으로 사용된다고 한다.
